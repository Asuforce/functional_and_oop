# オブジェクト指向言語と関数型言語の対比
## 研究の目的
　プログラミングを学び始めた時、オブジェクト指向という考え方を勉強しました。学校の授業などを通していくつかの言語に触れてみると、そのほとんどの言語がオブジェクト指向を取り入れたものであると気づかされました。JavaやRuby、PHPなど実際の開発の現場で使われている言語の多くもオブジェクト指向言語です。このように、身近なプログラミング言語の多くがオブジェクト指向を取り入れているのです。
　２０１５年の技術のトピックの一つに関数型言語が上がるようになりました。それまでは聞いたことが無い言葉だったので、どのような物か興味が湧きました。「副作用がない」ことや「関数を組み合わせる」ことが大きく取り上げられており、既存の言語とは全く違う感覚の物だと感じました。
　そこで関数型を学びつつ、今まで勉強してきたオブジェクト指向言語と対比させることで、より深くプログラミングの知識を得ることと、それぞれの言語をどのように使い分けていけばいいのかを考えることで今後のプログラミングに役立てたいと思い、この研究をテーマにしました。

## 研究進め方
　純関数型言語のHaskellを学びながら関数型の特徴を洗い出していき、関数型への解釈を進めました。Haskellはアメリカで生まれた純関数型言語です。オブジェクト指向言語としてはRubyとPHPを参考にしました。Rubyは日本で生まれたオブジェクト指向スクリプト言語です。純粋なオブジェクト指向言語として開発されました。PHPに関しては元々オブジェクト指向言語として作られたわけではないですが、度重なるバージョンアップによってオブジェクト指向の特徴を備えたものになっているので比較に使いました。
　関数型言語は経験が無いこともあり、大変苦労しながらの学習になりました。また、Haskellは「純」関数型言語と呼ばれていて、関数型を扱う上で敷居の低いと言われているScalaなどと比べて学習面でコストが高いということもあり研究は困難を極めました。完璧に理解することはまだできていませんが、関数型の考え方を学ぶことができオブジェクト指向言語との対比ができるくらいの知識がつきました。
プログラミング言語の歴史について
　コンピュータが登場した当時は、コンピュータへの命令に使用できるのは機械語と言われる2進数で表現したものしかありませんでした。それからアッセンブリ言語、高級言語、構造化言語と進化していきました。アッセンブリ言語は機械語を記号で置き換えられるようになりました。さらなる利便性を求め、人間が理解できる文字列で記述できる高級言語が生まれました。ここまでの進化は人間が機械への命令をしやすくするための発達を遂げたといえるでしょう。
　構造化言語では高級言語をさらに読みやすくするために多くの機能が追加されました。エドガー・ダイクストラによって構造化プログラミングというものが提唱されました。それまでの言語ではGOTO文を使って、繰り返し処理を記述していました。しかし、繰り返しの回数や条件が増えるほどコードの可読性が下がるという欠点がありました。構造化プログラミングでは順次進行、条件分岐、繰り返しの３つの構造を提唱し、GOTO文の廃止を宣言しました。
　しかし、構造化プログラミングだけでは巨大化するソフトウェアの更なる進化に耐えられなくなりました。そこで考案されたのがオブジェクト指向の考え方でした。クリステン・ニガードとオルヨハンダールによって1960年代に開発されたSimulaが最初のオブジェクト指向言語になります。
　その頃関数型言語も登場しました。1970年に台頭したLISPから関数型は発展を遂げました。その特徴から主に数学の分野や学術的なプログラミングとして使われてきました。オブジェクト指向も関数型も同じ頃から発展を繰り返してきた概念です。

## オブジェクト指向について
　オブジェクト指向言語は構造化プログラミングという考え方を元に、開発をより円滑に進めるために考えだされたプログラミング技法です。オブジェクトを中心に命令を出すことによってプログラムを書いていくのが特徴になります。オブジェクト指向言語と呼ばれるプログラミング言語はオブジェクト指向の技法を使わなくてもプログラミングができるようになっているのが特徴です。クラスという大きな枠組の中にメソッドと呼ばれる関数を定義し、クラスやメソッドを呼び出すことによって操作していきます。クラスはオブジェクトの設計図と言いかえられることもあります。また、クラスから生成されたオブジェクトの事をインスタンスと呼びます。オブジェクト指向では、このインスタンスを操作しながら様々な処理を実行していきます。
　一般的にオブジェクト指向は大規模な開発に向いているとされており、様々な事象の抽象化を行うことでプログラムを管理しやすくするといった特徴があります。
　最初のオブジェクト指向言語は1960年ごろに登場したSimulaという言語になります。それから50年たった今でもオブジェクト指向言語は現場の第一線で活躍するプログラミング技法です。現在の主流な言語の多くはオブジェクト指向の考え方を取り入れているものが多いです。よってオブジェクト指向の考え方を理解することで、多くの言語が学びやすくなると言えるでしょう。

### クラス
　クラスは設計図の役割を担う機能です。オブジェクト指向ではたくさんのクラスを定義し、組み合わせたり継承したりすることによってプログラムを書いていきます。クラスには物事の振る舞いを定義します。クラスからインスタンスを生成することによって、定義した機能（メソッド）を使う事ができます。具体例を挙げると、自動車クラスという車についての設計図が存在し、様々な車種がインスタンスとしてこの世の中に存在しています。自動車はたくさんの種類があるので、更に大型車、普通車、軽自動車といったクラスを定義することができます。今回は大型車クラスを追加で定義します。大型車クラスの基本構造は自動車なので、自動車クラスを継承して作ります。そうすることによって基本的な自動車の定義はそのままに、大型車だけの機能を大型車クラスに定義することができます。こうすることによって自動車の基本構造を気にせずに設計をすることができます。
　インスタンスの機能はクラスに依存しているので、クラスの機能を変更するだけでこのクラスから生成された全てのインスタンスに機能を反映することができます。このようにクラスを使いこなせば、一つ一つの設定を一度に変更することができ、様々な変更に柔軟に対応できるようになります。

### ポリモーフィズム（多様性）
　クラスを継承した時にメソッドを再定義（オーバーライド）することができます。そうすることで、同じメソッド名ながら機能が全く違うといった状況が生まれます。この事をポリモーフィズムと言います。ポリモーフィズムの利点は、振る舞いをオブジェクトに依存させることができる点です。同じメソッドを使ってもオブジェクトに任せた処理を発生させることができます。
カプセル化
　カプセル化とはオブジェクト内部にデータを隠すことです。これは定義したメソッドやデータを外部との結びつきを弱めるために行われます。多くのオブジェクト指向言語ではクラスに定義したメソッドや変数にプロパティをつけることで、外部からのアクセスを許可したり、内部だけの操作に限定したりするといったことができます。カプセル化によって、個々のオブジェクトの独立性を高めることができます。またオブジェクト内部の変更が直接外部に影響しなくなるので、保守性が高まるといった利点があります。

### 継承
　いくつかのクラスを作る時、設計に共通部分があるのにも関わらず、別々に全てのクラスを1から作成していると大変です。また、複数のクラスに同じ機能を重複して定義するはめになってしまいます。そこで、あるクラスが既に作成されていて、そのクラスを拡張して新しいクラスを作成することが可能です。このように他のクラスをベースとして新しいクラスを作成することをクラスの継承と言います。異なる部分を扱うクラスをサブクラスと表現し、サブクラスがあることが前提となりますが共通部分を扱うクラスをスーパークラスと呼びます。クラスはインスタンスを作るのが目的になりますが、継承はクラス自体の管理が目的になります。

## 関数型について
　関数型プログラミングは、オブジェクト指向や構造化プログラミングなどの考え方とは全く異なったスタイルでコーディングするプログラミング技法です。一番の特徴は関数を引数に取ることが出来ることで、その特徴を活かし関数を組み合わせてコーディングしていくのが一般的なスタイルです。また、関数型プログラミングでは副作用は生じません。副作用を生じさせないことによって参照透過性を守っているのです。他にも、使われるまで式を評価しない機能である遅延評価や、副作用を生じる処理が必要になった場合に用いるモナドなども関数型プログラミングにおいて重要な要素達です。厳密に言えば、副作用が生じない・遅延評価・モナドは関数型プログラミング特有の機能というわけではないのですが、関数型プログラミングがそれらの機能の使用を推奨するように設計されています。また、純粋な関数型言語では副作用を生じさせるような破壊的代入を許さないので上記の機能は確固たるものとなります。
　関数型プログラミングは宣言型プログラミングと呼ばれることもあり、そうした場合よく命令型プログラミング（手続き型プログラミング）と比較されます。両者の違いは、目的の結果を得るためのアプローチの仕方にあります。命令型では、結果を得るためにアルゴリズムを手順通りに記述します。一方宣言型では、結果を得るための方法を記述するのではなく、解くべき問題の性質を記述します。例えば、HTMLはどう見えるかを記述するものなので、宣言的であると言えます。
　オブジェクト指向言語と比較して際立って使われている事はありませんが、近年注目されてきています。関数型言語は関数を使って全てのコードを書きます。オブジェクト指向言語でも関数は使いますが、関数型の関数は数学の関数とほぼ同義になります。このことからも、同じ引数を与えた時必ず同じ結果が返ってくる特徴を裏付けることができます。この特徴によってコードの安全性が担保されます。欠点はオブジェクト指向言語以上に学習コストが高くなる点です。

### イミュータブル（永続データ）
　イミュータブルとは作成後にデータの変更ができないことを言います。これはデータの状態が変わらないともとれます。イミュータブルなデータの事は永続データとも表現されます。関数型言語では状態が変化することがないので、すべての変数はイミュータブルと言えます。何も変える事ができないのに変数と言うのは違和感があるかもしれませんが、関数型の世界では変数は不変のデータ（永続データ）になります。よって関数型の変数は後で別の値を再代入することができません。そのため変数を作ることを代入ではなく束縛と表現します。
　関数型の変数はオブジェクト指向言語の定数のような振る舞いをします。変数に値が束縛されるので、同じスコープ上で同じ名前の宣言はできなくなります。結果を変数に入れる場合は新しく変数を定義する必要があります。これは動的型付け言語に慣れている人からすると非常に不便に感じる特徴だと思います。しかし、関数型の世界では後述する副作用というものがない世界になります。一度定義されたものは変わらないことが保証されているためその世界が守られます。イミュータブルな事によって変数はいつでも同じデータを保証し、関数は同じ結果を返すことが保証されるのです。

### 副作用について
　ある動作による結果とは別に、他の部分に及んでしまう影響のことを副作用と呼びます。変数への再代入行為も副作用の一つです。副作用が存在することでプログラムに状態が生じてしまい、プログラマはコーディングの際に状態を考慮しなければなりません。副作用が存在することでプログラムが複雑になり、バグの発生率が上がると言われています。
　また、副作用のないプログラムは参照透過性があると言えます。参照透過性とは、関数に同じ変数を引数として与えてやれば同じ値を返す性質のことを言います。参照透過性があることで関数の動作だけを考慮すれば良くなるので、プログラマにとって可読性が上がり、コーディングしやすくなります。
　一見すると副作用の存在しない関数型の方が優れているように思えますが、実用的なプログラムには必ず副作用が存在します。関数型では、入出力などの副作用処理が必要になった場合モナドという概念を使い解決します。

### モナド
　純粋関数型言語のHaskellでは副作用を生じる処理を基本的に書きません。そうはいっても、プログラムを書く上で入出力といった操作は必須になります。そこで、入出力処理を実現するためにモナドという機能を利用します。Haskellでは遅延評価を採用しているので、入出力処理を意図した順序で行うことに不都合を生じかねません。モナドは遅延評価を行った式達の実行順序の整合性を取る仕組みも実現します。

### 遅延評価
　遅延評価とは式の評価を実際に必要になる場面になるまで遅らせる評価方法のことを言います。遅延評価をすることで冗長性のある演算を省くことができるので、式評価が効率的になり演算スピードが向上します。式評価を遅らせる際に、後にちゃんとその式を評価できるようにメモリ上にメモを残しておきます。このメモのことをサンクと言います。遅延評価は非正格評価とも呼ばれます。その対となる正格評価は、式が渡された時点で評価を開始する評価方法のことを言います。
　また条件式において、一つ目に定義された条件式に当てはまった場合二つ目以降の条件式は評価されません。この性質により、二つ目以降の条件式に無限ループ処理が記述されていたとしても、一つ目の条件式に当てはまってしまえば無限ループを避けることができます。これは非正格評価による特徴と言えます。正格評価では、全ての式が評価されますので条件式に無限ループの処理が含まれていたら避けることができないのです。

## コードから比較する
　関数型をより理解するために、実際にコードを書き、オブジェクト指向と比較するといった事を行いました。関数を作る章では実際に関数型の関数を作ることで関数型に対する理解を深めました。迷路アルゴリズムでは更に踏み込んだコードを書くことで双方にどういった差があるのかをまとめました。

### 関数を作る
　関数型の関数を体感するために、実際に関数を作成してみました。関数型の関数は数学の関数と同義とのことでしたが、オブジェクト指向言語から学習した人からすると掴みにくい特徴だと思います。オブジェクト指向言語の関数と対比させながら、関数型の関数を紐解きたいと思います。

#### 実際に問題を解く
　入力値として整数の配列またはリストが与えられます。0から数えてn番目の要素にはnを掛け、それらすべてを足し合わせて出力として返すという問題です。今回は以下のデータを入力し、400が答えになる関数を作ります。

[10,20,30,40,50]を与えたとすると
10 * 0 + 20 * 1 + 30 * 2 + 40 * 3 + 50 * 4
A.400

#### オブジェクト指向言語の場合(PHP)
オブジェクト指向型言語で上記の問題を実装すると下記のコードになります。

```Ruby
function calc($array)
{
    $ret = 0;;
        for ($i=0; $i<count($array); $i++) {
            $ret = $ret + $array[$i] * $i;
        }
    return $ret;
}
```

`$array = [10,20,30,40,50]`が入力値とすると、for文で5回繰り返しが行われ、n番目の要素にnを掛けたものが既存の$retに足され、それが$retに再代入されます。
最後に結果が返るというのがオブジェクト指向言語で実装した場合の一般的な記述だと考えられます。

#### 関数型言語の場合(Haskell)
関数型言語のHaskellで上記の問題を実装すると下記になります。
mul関数とcalc関数が定義されています。

```Haskell
mul (i,x) = i * x
calc xs = foldl (+) 0 (map mul (zip [0..] xs))
```
ここからは[10,20,30,40,50]を入力値とし、以下の状態で説明をします。

```Haskell
calc [10,20,30,40,50] foldl (+) 0 (map mul (zip [0..] [10,20,30,40,50] ))
```

#### 関数型の処理
　コードが短くて済むことは確認できましたがHaskellは何をしているのかがわかりにくいと思います。このコードではMapReduceという方法が使われております。これはmap関数とreduceというやり方を組み合わせて使うスタイルになります。ここからは一つ一つを紐解いていきたいと思います。
　最初に関数型の関数は数学の関数と同義だと言いました。その定義からすると括弧が付いているものから優先されると予想できると思います。まさにその通りで右から数えて三番目にあるzipという関数が最初に実行されます。zip関数の機能はリストをまとめる事です。zip関数は二つのリストからタプル（２つのデータ1個のペアとして扱える概念）のリストを作ることができます。今回はaというリストを引数として用意しました。

```Haskell
let a = [10, 20, 30, 40, 50]
zip [0..] a => [(0,10),(1,20),(2,30),(3,40),(4,50)]
```

現在のcalc関数：`foldl (+) 0 (map mul [(0,10),(1,20),(2,30),(3,40),(4,50)])`

　次に行われるのが右から二番目のmulという関数に見えますが実はmap関数が適用されます。map関数は第一引数に関数を、第二引数にリストを取る関数だからです。関数型では関数を引数に取ることができる関数が存在します。こういった関数の事を高階関数と言います。map関数は第二引数のリストのそれぞれの要素に第一引数の関数を適用する関数になります。
　今回の問題ではn番目の要素にnを掛けるといったロジックが必要になります。それをこのmap関数を使うことによって実現します。リストのそれぞれの要素はタプル型で、1番目がカウンタ（何番目か）、2番目がn番目の要素となります。1番目に２番目を掛け合わせる事で期待する結果が得れそうです。これらの考えを関数で実装すると下記のようになります。

```Haskell
mul (i, z) = i * x
```

タプル型を引数にとるmul関数です。タプルの1番目と2番目を掛けあわせた結果が返り値になります。
それではmap関数を実行してみます

`map mul [(0,10),(1,20),(2,30),(3,40),(4,50)] => [0,20,60,120,200]`
現在のcalc関数：`foldl (+) 0 [0,20,60,120,200]`

　次に実行される関数を追う前にreduceという概念について紹介します。reduceはリストの要素を何らかの方法で1つにまとめることを指します。このことを「畳み込み」と表現することもあります。次にやりたいことは下記のように、リストのそれぞれの値を足すことです。

`((((0 + 0) + 20) + 60) + 120) + 200 => 400`

畳み込みでは初期値0に対して、要素を順番に足すといったことが可能です。Haskellではfoldlという関数があるのでそれを使って畳み込みを行います。
　それではfoldl関数を使ってみます。foldl関数は第一引数に演算子、第二引数に初期値、第三引数にリストを取る関数です。下記のように目的の400という値にたどり着くことができました。

```Haskell
foldl (+) 0 [0,20,60,120,200] => 400
````

calc関数の処理の流れを再掲します。

```Haskell
calc xs = foldl (+) 0 (map mul (zip [0..] xs))
calc [10,20,30,40,50] foldl (+) 0 (map mul (zip [0..] [10,20,30,40,50] ))
foldl (+) 0 (map mul [(0,10),(1,20),(2,30),(3,40),(4,50)])
foldl (+) 0 [0,20,60,120,200]
400
```

#### まとめ
このように関数型言語のHaskellを使用して関数型の関数の流れをつかむことができたと思います。オブジェクト指向で定義する関数とは違っていますが、関数同士を組み合わせることで期待する結果を導くというスタイルになっています。

### 迷路アルゴリズム
　関数型とオブジェクト指向それぞれの特徴をより比較しやすくするため、最短経路を出す迷路アルゴリズムをオブジェクト指向言語はRubyを、関数型言語はHaskellを使用し実装しました。右図のように迷路の書かれたテキストデータを入力値としてとり、SからGまでの最短経路を出力します。何も書いていないスペースを道とし、アスタリスクの部分を壁とみなします。そして、実行した結果として出力された最短経路をアットマークで出力します。
　下図が実際に実装したコードの一部です。左がRuby、右がHaskellになります。Rubyではクラスを使った実装をしていて、機能はメソッドごとにまとめて記述されています。for文やif文の構文はプログラマにとって記述しやすい書式ではありますが、インデントが深くなり、また全体的にコードが長くなります。
　一方Haskellではクラスという概念は存在せず、関数を組み合わせることによって実装しました。for文は存在しないので再帰を使って繰り返し処理を実現しています。このような関数型のスタイルは、Rubyのようなオブジェクト指向と比べるとコードが短くなります。Rubyのコードでは132行、Haskellのコードでは64行となりコードの長さだけで行ったら二倍以上の差を生じる結果となりました。

## それぞれのパラダイムについて
　物事の考え方や概念の事をパラダイムと呼び、特にオブジェクト指向や関数型などプログラミング手法についての概念のことをプログラミングパラダイム（以下パラダイム）と呼びます。2つのパラダイムは同じくらいの歴史を持つものです。しかし、その普及率は同じとは言いがたいのが現状です。なぜオブジェクト指向が普及したのか、また関数型がなぜ普及しないのかについてまとめました。

### オブジェクト指向がなぜ普及したか
　オブジェクト指向が登場する以前の開発は今現在と比較して、小規模な開発が主に行われていました。しかし、コンピュータの性能が向上するにつれて大規模な開発が行われるようになりました。ソフトウェアが大規模になるにつれて、コードの量が増えコストがどんどんあがっていき、1960年代には「ソフトウェア危機」と言うような事も唱えられるようになりました。これはコンピュータの性能向上するにつれ、ソフトウェアが複雑化してしまい、問題を引き起こす要因になると考えられていました。そんな中考えだされたのがエドガー・ダイクストラによる構造化プログラミングというものでした。コードの機能を部品化し、再利用性を恒常化することを念頭に置いた概念で、オブジェクト指向の前進となりました。構造化プログラミングによって関数の再利用や部品化はできました。しかし、データに関しては十分に抽象化ができず、構造化が不十分でした。そこでデータをオブジェクトとして扱う方法がオブジェクト指向として考案されました。この考えによって関数だけでなくデータも全て含んだオブジェクトを作ることができるようになりました。オブジェクトに対するメッセージを発する事で様々な処理を実行し、コードの整理と再利用性を実現させることができるようになりました。
　これらの経緯を考察するとわかるようにオブジェクト指向は開発における危機を乗り越えるために考えられた概念です。そのためオブジェクト指向を導入した言語が多く誕生することも頷けます。現在でも開発の現場で利用されているC++やC#、Javaなどもオブジェクト指向の考え方を備えております。これらの事からオブジェクト指向が普及した一番大きな要因は開発の現場がもとめていた物だったからだということが理解できると思います。オブジェクト指向は今でも使われており、最も普及したパラダイムだと考えられます。関数型だけでは出来無い事を補うためにも、今後共長く使われると予想されます。

### 関数型が普及しない理由
　第一の理由として、学習コストが高いことにあると考えられます。実際プログラムに意味を持たせるためには副作用は必要不可欠な存在であると上記で述べました。それを副作用のない、参照透過性のある関数をうまく組み合わせてコーディングすることができるだけの能力を持ち合わせた人はそう多くないと思われます。オブジェクト指向とプログラミングスタイルがかけ離れていることも、もともと命令型を学んでいた人にとっては学習が億劫になる原因の一つです。実際、私たちが関数型を研究する際、いままで学んできたプログラミング概念を一度リセットする必要がありとても苦労しました。いままで当たり前のように使っていた変数への再代入は副作用を生じる行為のため使用できません。再代入ができないことによりfor文やwhile文を使った繰り返し処理も使用できません。関数型の繰り返し処理は基本的に再帰によって実現されます。このように、オブジェクト指向と比べるとかなり異なった形の関数型の設計になかなか慣れることができませんでした。
　第二に、リファレンスや関数型に関する記事の不足であると考えられます。関数を調べたくとも日本語で記述されたリファレンスが充実していないので関数型を学ぶことすら困難な状態です。
　第三に、数学的な知識を要するからであると考えられます。関数型ではプログラム中に副作用を生じさせる際にモナドという機能を利用します。モナドには様々な種類があり、深いところに足を踏み込もうとなると圏論についてまで言及せざるを得なくなります。私たちはそこまで追究する余裕がなかったので、モナドについては入出力処理を実現するIOモナドのみ学習することにしました。しかし実際は、関数型で実用的なプログラムを組むためにはモナドを使いこなせることが求められるのです。
　上記のような理由により、関数型の領域に足を踏み入れるには敷居が高いように感じられるのかもしれません。

## まとめ
　今回の研究ではオブジェクト指向と関数型について研究を進めていき、両者の特徴について比較を行いました。その結果から言えることは、プログラミングをより理解していくためにはオブジェクト指向と関数型のそれぞれの特徴を捉える必要がある、ということです。どちらの考え方も理解した上で、双方の長所を選りすぐったコーディングができることが理想だと思われます。そうは言っても関数型言語はオブジェクト指向言語から学んだ人からすると、奇妙で難しいものに感じると思います。関数型をわざわざ学ぶ必要がないと感じるかもしれません。しかし、最近の新しい言語ではオブジェクト指向と関数型の考えを併せ持つものが登場しています。これらの言語の事をマルチパラダイム言語と言います。ScalaやSwiftと言った言語がそれにあたります。これらはwebアプリケーションのサーバサイドやiOSアプリケーションを支える言語です。これらの事からオブジェクト指向、関数型、双方の欠点を補うために、また関数型からプログラミングを始めた人のために、マルチパラダイム言語が登場したと考えられます。オブジェクト指向が開発者の問題を解決するために考えだされたように、関数型も必要になりつつあるからこそ、このような仕様の言語が登場していると考えられます。
　このように関数型は注目を浴びるようになってきました。インターネット上では関数型とオブジェクト指向のどちらが優れているかの論争も繰り広げられることがあります。しかし、ソフトウェア工学には「No Silver Bullet（銀の弾丸などない）」と言った言葉があるように、全ての問題を解決できる方法は無いと言われております。
　コンピュータが発達するにつれて、人々が訴求するものがどんどん変化し多様化している昨今では開発者は一つの概念だけで問題解決ができなくなってきました。そういった時代だからこそ、開発者は一つの概念に縛られることなく幅広い知識を学ぶ必要があると思います。オブジェクト指向と関数型もその一つだと考えられます。どれかひとつの考え方が優れているということではなく、互いの考え方の一長一短を理解してプログラミングをしていくことが大切だと考えられます。
